# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BKGGeocoderDialog
                                 A QGIS plugin
 uses BKG geocoding API to geocode adresses
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-10-19
        git sha              : $Format:%H$
        copyright            : (C) 2018 by GGR
        email                : franke@ggr-planung.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic, QtWidgets
from qgis.PyQt.QtCore import pyqtSignal, Qt, QVariant
from qgis import utils
from qgis.core import (QgsCoordinateReferenceSystem, QgsField,
                       QgsPointXY, QgsGeometry, QgsMapLayerProxyModel)
from qgis.PyQt.QtWidgets import QComboBox, QCheckBox, QMessageBox

from interface.dialogs import (ProgressDialog, ReverseGeocodingDialog,
                               InspectResultsDialog)
from interface.map_tools import FeaturePicker
from interface.utils import clone_layer, TerrestrisBackgroundLayer
from geocoder.bkg_geocoder import BKGGeocoder
from geocoder.geocoder import Geocoding, FieldMap
from config import Config

config = Config()
UI_PATH = os.path.join(os.path.dirname(__file__), 'ui')

BKG_FIELDS = [
    ('bkg_feature_id', QVariant.Int, 'int4'),
    ('bkg_n_results', QVariant.Int, 'int2'),
    ('bkg_i', QVariant.Double, 'int2'),
    ('bkg_typ', QVariant.String, 'text'),
    ('bkg_text', QVariant.String, 'text'),
    ('bkg_score', QVariant.Double, 'float8'),
    ('bkg_treffer', QVariant.String, 'text')
]

RS_PRESETS = [
    ('Schleswig-Holstein', '01*'),
    ('Freie und Hansestadt Hamburg', '02*'),
    ('Niedersachsen', '03*'),
    ('Freie Hansestadt Bremen', '04*'),
    ('Nordrhein-Westfalen', '05*'),
    ('Hessen', '06*'),
    ('Rheinland-Pfalz', '07*'),
    ('Baden-Württemberg', '08*'),
    ('Freistaat Bayern', '09*'),
    ('Saarland', '10*'),
    ('Berlin', '11*'),
    ('Brandenburg', '12*'),
    ('Mecklenburg-Vorpommern', '13*'),
    ('Freistaat Sachsen', '14*'),
    ('Sachsen-Anhalt', '15*'),
    ('Freistaat Thüringen', '16*')
]

def clear_layout(layout):
    while layout.count():
        child = layout.takeAt(0)
        if not child:
            continue
        if child.widget():
            child.widget().deleteLater()
        elif child.layout() is not None:
            clear_layout(child.layout())


class MainWidget(QtWidgets.QDockWidget):
    ui_file = 'main_dockwidget.ui'
    closingWidget = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(MainWidget, self).__init__(parent)

        self.iface = utils.iface
        self.canvas = self.iface.mapCanvas()
        ui_file = self.ui_file if os.path.exists(self.ui_file) \
            else os.path.join(UI_PATH, self.ui_file)
        uic.loadUi(ui_file, self)
        self.setAllowedAreas(
            Qt.RightDockWidgetArea | Qt.LeftDockWidgetArea
        )
        self.setupUi()
        self.output_layer = None
        self.result_cache = {}

    def setupUi(self):
        actions = self.iface.addLayerMenu().actions()
        for action in actions:
            if action.objectName() == 'mActionAddDelimitedText':
                self.import_csv_action = action
                break
        self.import_csv_button.clicked.connect(self.import_csv_action.trigger)
        self.export_csv_button.clicked.connect(self.export_csv)
        self.attribute_table_button.clicked.connect(self.show_attribute_table)
        self.reversegeocoding_button.clicked.connect(self.reverse_geocode)
        self.request_start_button.clicked.connect(self.geocode)
        self.request_stop_button.clicked.connect(lambda: self.geocoding.kill())
        self.request_stop_button.setVisible(False)
        self.layer_combo.setFilters(QgsMapLayerProxyModel.VectorLayer)
        self.layer_combo.layerChanged.connect(self.register_layer)

        self.rs_combo.addItem('Eingabehilfe Bundesländer')
        self.rs_combo.model().item(0).setEnabled(False)
        for name, rs in RS_PRESETS:
            self.rs_combo.addItem(name, rs)
        self.rs_combo.currentIndexChanged.connect(
            lambda: self.rs_edit.setText(self.rs_combo.currentData()))
        self.rs_edit.editingFinished.connect(
            lambda: self.rs_combo.setCurrentIndex(0))

        self.feature_picker = FeaturePicker(
            self.featurepicker_button, canvas=self.canvas)
        self.feature_picker.feature_picked.connect(self.inspect_results)
        self.setup_config()

    def setup_config(self):
        self.search_and_check.setChecked(config.logic_link == 'AND')
        self.search_and_check.toggled.connect(
            lambda: setattr(config, 'logic_link', 'AND'))
        self.search_or_check.toggled.connect(
            lambda: setattr(config, 'logic_link', 'OR'))

        self.api_key_edit.setText(config.api_key)
        self.api_key_edit.editingFinished.connect(
            lambda: setattr(config, 'api_key', self.api_key_edit.text()))
        crs = QgsCoordinateReferenceSystem(config.projection)
        self.output_projection_select.setCrs(crs)

        self.output_projection_select.crsChanged.connect(
            lambda crs: setattr(config, 'projection', crs.authid()))

        self.selected_features_only_check.setChecked(
            config.selected_features_only)
        self.selected_features_only_check.toggled.connect(
            lambda checked: setattr(config, 'selected_features_only', checked))

        self.rs_edit.setText(config.rs)
        self.rs_edit.textChanged.connect(
            lambda text: setattr(config, 'rs', text))

        self.use_rs_check.setChecked(config.use_rs)
        self.use_rs_check.toggled.connect(
            lambda checked: setattr(config, 'use_rs', checked))

    def inspect_results(self, feature):
        results = self.result_cache.get(feature.id(), None)
        # ToDo: warning dialog or pass it to results diag and show warning there
        if not results:
            return
        self.output_layer.select(feature.id())
        dialog = InspectResultsDialog(self.output_layer, feature, results,
                                      self.canvas, parent=self)
        dialog.show()

    def reverse_geocode(self):
        dialog = ReverseGeocodingDialog(parent=self)
        dialog.show()

    def geocode(self):
        dialog = ProgressDialog(parent=self)
        dialog.show()

    def show_attribute_table(self):
        if not self.output_layer:
            return
        self.iface.showAttributeTable(self.output_layer)

    def export_csv(self):
        if not self.output_layer:
            return
        self.iface.setActiveLayer(self.output_layer)
        actions = self.iface.layerMenu().actions()
        for action in actions:
            if action.objectName() == 'mActionLayerSaveAs':
                break
        action.trigger()

    def closeEvent(self, event):
        self.closingWidget.emit()
        event.accept()

    def show(self):
        self.iface.addDockWidget(Qt.LeftDockWidgetArea, self)
        self.setFloating(True);
        self.resize(self.sizeHint().width(), self.sizeHint().height())
        geometry = self.geometry()
        self.setGeometry(500, 500, geometry.width(), geometry.height())

    def log(self, text, color='black'):
        self.log_edit.insertHtml(
            f'<span style="color: {color}">{text}</span><br>')
        scrollbar = self.log_edit.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())

    def register_layer(self, layer):
        '''
        add field checks depending on given layer to UI and preset
        layer related UI elements
        '''
        bkg_f = [f[0] for f in BKG_FIELDS]
        if not layer:
            return
        self.result_cache = {}
        self.field_map = FieldMap(layer, ignore=bkg_f,
                                  keywords=BKGGeocoder.keywords)
        # remove old widgets
        clear_layout(self.parameter_grid)

        for i, field_name in enumerate(self.field_map.fields()):
            checkbox = QCheckBox()
            checkbox.setText(field_name)
            combo = QComboBox()
            combo.addItem('Volltextsuche', None)
            for key, text in BKGGeocoder.keywords.items():
                combo.addItem(text, key)

            def checkbox_changed(state, combo, field_name):
                checked = state != 0
                self.field_map.set_active(field_name, checked)
                combo.setEnabled(checked)
            checkbox.stateChanged.connect(
                lambda s, c=combo, f=field_name : checkbox_changed(s, c, f))
            # set initial check state
            checkbox_changed(self.field_map.active(field_name), combo,
                             field_name)

            def combo_changed(idx, combo, field_name):
                self.field_map.set_keyword(field_name, combo.itemData(idx))
            combo.currentIndexChanged.connect(
                lambda i, c=combo, f=field_name : combo_changed(i, c, f))
            # set initial combo index
            cur_idx = combo.findData(self.field_map.keyword(field_name))
            combo_changed(cur_idx, combo, field_name)

            self.parameter_grid.addWidget(checkbox, i, 0)
            self.parameter_grid.addWidget(combo, i, 1)
            # initial state
            checked = self.field_map.active(field_name)
            keyword = self.field_map.keyword(field_name)
            checkbox.setChecked(checked)
            if keyword is not None:
                combo_idx = combo.findData(keyword)
                combo.setCurrentIndex(combo_idx)
                combo.setEnabled(checked)

        #n_selected = layer.selectedFeatureCount()
        #self.n_selected_label.setText(
            #'({} Feature(s) selektiert)'.format(n_selected))

    def geocode(self):
        layer = self.layer_combo.currentLayer()
        if not layer:
            return

        backgroundGrey = TerrestrisBackgroundLayer(
            groupname='Hintergrundkarten')
        backgroundGrey.draw()

        rs = config.rs if self.use_rs_check.isChecked() else None
        bkg_geocoder = BKGGeocoder(config.api_key, srs=config.projection,
                                   logic_link=config.logic_link, rs=rs)
        features = layer.selectedFeatures() if config.selected_features_only \
            else layer.getFeatures()
        self.geocoding = Geocoding(bkg_geocoder, self.field_map,
                                   features=features, parent=self)

        cloned = clone_layer(layer, name=f'{layer.name()}_ergebnisse',
                             srs=config.projection, features=features)
        self.output_layer = cloned

        self.geocoding.message.connect(self.log)
        self.geocoding.progress.connect(self.progress_bar.setValue)
        self.geocoding.feature_done.connect(self.store_results)
        self.geocoding.error.connect(lambda msg: self.log(msg, color='red'))
        self.geocoding.finished.connect(self.done)

        self.feature_picker.set_layer(self.output_layer)

        self.tab_widget.setCurrentIndex(2)
        active_count = self.field_map.count_active()

        if active_count == 0:
            QMessageBox.information(
                self, 'Fehler',
                (u'Es sind keine Adressfelder ausgewählt.\n\n'
                 u'Start abgebrochen...'))
            return

        field_names = cloned.fields().names()
        add_fields = [QgsField(n, q, d) for n, q, d in BKG_FIELDS
                      if n not in field_names]
        cloned.dataProvider().addAttributes(add_fields)
        cloned.updateFields()

        self.request_start_button.setVisible(False)
        self.request_stop_button.setVisible(True)
        self.log(f'<br>Starte Geokodierung <b>{layer.name()}</b>')
        self.geocoding.start()

    def done(self, success: bool):
        if success:
            self.log('Geokodierung erfolgreich abgeschlossen')
            extent = self.output_layer.extent()
            self.canvas.setExtent(extent)
            self.canvas.refresh()
        self.request_start_button.setVisible(True)
        self.request_stop_button.setVisible(False)

    def store_results(self, feature, results):
        self.result_cache[feature.id()] = results
        if results:
            results.sort(key=lambda x: x['properties']['score'])
            best = results[0]
        else:
            best = None
        self.set_result(feature, best)

    def set_result(self, feature, result, focus=False):
        '''
        bkg specific
        set result to feature of given layer
        focus map canvas on feature if requested
        '''
        layer = self.output_layer
        if not layer.isEditable():
            layer.startEditing()
        fidx = layer.fields().indexFromName
        feat_id = feature.id()
        if result:
            coords = result['geometry']['coordinates']
            geom = QgsGeometry.fromPointXY(QgsPointXY(coords[0], coords[1]))
            properties = result['properties']
            layer.changeGeometry(feat_id, geom)
            layer.changeAttributeValue(
                feat_id, fidx('bkg_typ'), properties['typ'])
            layer.changeAttributeValue(
                feat_id, fidx('bkg_text'), properties['text'])
            layer.changeAttributeValue(
                feat_id, fidx('bkg_score'), properties['score'])
            layer.changeAttributeValue(
                feat_id, fidx('bkg_treffer'), properties['treffer'])
        else:
            layer.changeAttributeValue(
                feat_id, fidx('bkg_typ'), '')
            layer.changeAttributeValue(
                feat_id, fidx('bkg_score'), 0)
        #layer.updateFeature(feature)
        if focus:
            layer.removeSelection()
            layer.select(feat_id)
            self.canvas.zoomToSelected(layer)

